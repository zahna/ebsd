import os
import md5 
import md5crypt
import random
import time
import smbpasswd
import subprocess
import syslog
import base64
import netifaces
import networking
import sys

sys.path.append('/etc/rc.d')
sys.path.append('/usr/local/etc/rc.d')

def now():
    '''Return unix time'''
    return int(str(time.time()).split('.')[0])

def sysctl(var=None):
    '''Just like sysctl()'''
    if var:
        p = subprocess.Popen(['sysctl', '-n', var], shell=False, stdin=None, stdout=subprocess.PIPE, stderr=None).communicate()[0]
    else:
        return ''
    return p

class Appliance(object):
    '''The appliance object.  It holds the functions for controlling an appliance.
    ''' 

    def __init__(self, config):
        self.config = config
        self.needCommit = config.needCommit

    def authGenPasswdFiles(self):
        '''Create passwd files
        '''
        # Get a list of unique usernames
        userdict = self.config.getVars('user.')
        usernamelist = []
        for key in userdict.keys():
            username = key.split('.')[1]
            if not username in usernamelist:
                usernamelist.append(username)
        # If the passwd files exist, delete them
        if os.path.exists('/etc/passwd'):
            os.unlink('/etc/passwd')
        if os.path.exists('/etc/master.passwd'):
            os.unlink('/etc/master.passwd')

        f = open('/etc/passwd', 'a')
        # Write root's info
        f.write('%s:%s:%s:%s:%s:%s:%s\n' % ('root', '*', userdict['user.root.uid'], userdict['user.root.gid'], userdict['user.root.gecos'], userdict['user.root.home'], userdict['user.root.shell']))
        # Write the basic users
        f.write('toor:*:0:0:Bourne-again Superuser:/root:\ndaemon:*:1:1:Owner of many system processes:/root:/usr/sbin/nologin\noperator:*:2:5:System &:/:/usr/sbin/nologin\nbin:*:3:7:Binaries Commands and Source:/:/usr/sbin/nologin\ntty:*:4:65533:Tty Sandbox:/:/usr/sbin/nologin\nkmem:*:5:65533:KMem Sandbox:/:/usr/sbin/nologin\ngames:*:7:13:Games pseudo-user:/usr/games:/usr/sbin/nologin\nnews:*:8:8:News Subsystem:/:/usr/sbin/nologin\nman:*:9:9:Mister Man Pages:/usr/share/man:/usr/sbin/nologin\nsshd:*:22:22:Secure Shell Daemon:/var/empty:/usr/sbin/nologin\nsmmsp:*:25:25:Sendmail Submission User:/var/spool/clientmqueue:/usr/sbin/nologin\nmailnull:*:26:26:Sendmail Default User:/var/spool/mqueue:/usr/sbin/nologin\nbind:*:53:53:Bind Sandbox:/:/usr/sbin/nologin\nproxy:*:62:62:Packet Filter pseudo-user:/nonexistent:/usr/sbin/nologin\n_pflogd:*:64:64:pflogd privsep user:/var/empty:/usr/sbin/nologin\n_dhcp:*:65:65:dhcp programs:/var/empty:/usr/sbin/nologin\nuucp:*:66:66:UUCP pseudo-user:/var/spool/uucppublic:/usr/local/libexec/uucp/uucico\npop:*:68:6:Post Office Owner:/nonexistent:/usr/sbin/nologin\nwww:*:80:80:World Wide Web Owner:/nonexistent:/usr/sbin/nologin\nnobody:*:65534:65534:Unprivileged user:/nonexistent:/usr/sbin/nologin\ndhcpd:*:1001:1001:DHCP Daemon:/nonexistent:/usr/sbin/nologin\n')
        # Write out all other users
        for username in usernamelist:
            if username != 'root':
                f.write('%s:%s:%s:%s:%s:%s:%s\n' % (username, '*', userdict['user.%s.uid'%username], userdict['user.%s.gid'%username], userdict['user.%s.gecos'%username], userdict['user.%s.home'%username], userdict['user.%s.shell'%username]))
        f.close()

        f = open('/etc/master.passwd', 'a')
        # Write out root's info
        f.write('%s:%s:%s:%s:%s:%s:%s:%s\n' % ('root', userdict['user.root.md5crypt'], userdict['user.root.uid'], userdict['user.root.gid'], ':0:0', userdict['user.root.gecos'], userdict['user.root.home'], userdict['user.root.shell']))
        # Write the basic users
        f.write('toor:*:0:0::0:0:Bourne-again Superuser:/root:\ndaemon:*:1:1::0:0:Owner of many system processes:/root:/usr/sbin/nologin\noperator:*:2:5::0:0:System &:/:/usr/sbin/nologin\nbin:*:3:7::0:0:Binaries Commands and Source:/:/usr/sbin/nologin\ntty:*:4:65533::0:0:Tty Sandbox:/:/usr/sbin/nologin\nkmem:*:5:65533::0:0:KMem Sandbox:/:/usr/sbin/nologin\ngames:*:7:13::0:0:Games pseudo-user:/usr/games:/usr/sbin/nologin\nnews:*:8:8::0:0:News Subsystem:/:/usr/sbin/nologin\nman:*:9:9::0:0:Mister Man Pages:/usr/share/man:/usr/sbin/nologin\nsshd:*:22:22::0:0:Secure Shell Daemon:/var/empty:/usr/sbin/nologin\nsmmsp:*:25:25::0:0:Sendmail Submission User:/var/spool/clientmqueue:/usr/sbin/nologin\nmailnull:*:26:26::0:0:Sendmail Default User:/var/spool/mqueue:/usr/sbin/nologin\nbind:*:53:53::0:0:Bind Sandbox:/:/usr/sbin/nologin\nproxy:*:62:62::0:0:Packet Filter pseudo-user:/nonexistent:/usr/sbin/nologin\n_pflogd:*:64:64::0:0:pflogd privsep user:/var/empty:/usr/sbin/nologin\n_dhcp:*:65:65::0:0:dhcp programs:/var/empty:/usr/sbin/nologin\nuucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/local/libexec/uucp/uucico\npop:*:68:6::0:0:Post Office Owner:/nonexistent:/usr/sbin/nologin\nwww:*:80:80::0:0:World Wide Web Owner:/nonexistent:/usr/sbin/nologin\nnobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/usr/sbin/nologin\ndhcpd:*:1001:1001::0:0:DHCP Daemon:/nonexistent:/usr/sbin/nologin\n')
        # Write out all other users
        for username in usernamelist:
            if username != 'root':
                f.write('%s:%s:%s:%s:%s:%s:%s:%s\n' % (username, userdict['user.%s.md5crypt'%username], userdict['user.%s.uid'%username], userdict['user.%s.gid'%username], ':0:0', userdict['user.%s.gecos'%username], userdict['user.%s.home'%username], userdict['user.%s.shell'%username]))
        f.close()

        # Regenerate the pwd.db files
        subprocess.call(['pwd_mkdb','-p','-d','/etc','/etc/master.passwd'])

    def authGenGroupFiles(self):
        '''Create the group file
        '''
        groupdict = self.config.getVars('group')
        # Get a list of unique groupnames
        groupnamelist = []
        for key in groupdict.keys():
            groupname = key.split('.')[1]
            if not groupname in groupnamelist:
                groupnamelist.append(groupname)

        # If the group file exists, delete it
        if os.path.exists('/etc/group'):
            os.unlink('/etc/group')

        # Recreate group file
        f = open('/etc/group', 'a')
        # Write the included groups
        f.write('daemon:*:1:\nkmem:*:2:\nsys:*:3:\ntty:*:4:\noperator:*:5:root\nmail:*:6:\nbin:*:7:\nnews:*:8:\nman:*:9:\ngames:*:13:\nstaff:*:20:\nsshd:*:22:\nsmmsp:*:25:\nmailnull:*:26:\nguest:*:31:\nbind:*:53:\nproxy:*:62:\nauthpf:*:63:\n_pflogd:*:64:\n_dhcp:*:65:\nuucp:*:66:\ndialer:*:68:\nnetwork:*:69:\naudit:*:77:\nwww:*:80:\nnogroup:*:65533:\nnobody:*:65534:\ndhcpd:*:1001:\n')
        for name in groupnamelist:
            f.write('%s:%s:%s:%s\n' % (name, '*', groupdict['group.%s.id'%name], groupdict['group.%s.members'%name]))
        f.close()

    def authGenSmbFiles(self):
        '''Create samba user account file
        '''
        # Get a list of unique usernames
        userdict = self.config.getVars('user\.')
        usernamelist = []
        for key in userdict.keys():
            username = key.split('.')[1]
            if not username in usernamelist:
                usernamelist.append(username)

        # Make sure dir is there
        if not os.path.exists('/usr/local/etc/samba'):
            os.mkdir('/usr/local/etc/samba')
        # Write new smbpasswd
        f = open('/usr/local/etc/samba/smbpasswd', 'w')
        for username in usernamelist:
            f.write('%s:%s:%s:%s:%s\n' % (username, self.config.getVar('user.%s.uid'%username), self.config.getVar('user.%s.spasswd'%username), self.config.getVar('user.%s.sflags'%username), self.config.getVar('user.%s.lct'%username)))
        f.close()

    def authSetMd5(self, username, password):
        '''Set a user's md5 password
        '''
        # Supposedly this next line using crypt will make an md5crypt string
        #self.config.setVar('user.%s.md5crypt' % username, crypt.crypt(password, '$1$%s' % self.randStr(8)))
        self.config.setVar('user.%s.md5crypt' % username, md5crypt.unixMd5Crypt(password, self.randStr(8)))
        self.config.setVar('user.%s.md5lighttpd' % username, md5crypt.lighttpdMd5Crypt(password, self.randStr(8)))
        self.config.setVar('user.%s.md5userpass' % username, md5.new(username+password).hexdigest())
        self.config.setVar('user.%s.md5' % username, md5.new(password).hexdigest())

    def authSetSmbPassword(self, username, password):
        '''Set a user's smb password
        '''
        self.config.setVar('user.%s.spasswd' % username, '%s:%s' % (smbpasswd.lmhash(password), smbpasswd.nthash(password)))

    def cfgDump(self):
        '''Dump every config key value pair in the database
        '''
        return self.config.dump()

    def cfgSave(self, target='/cfg'):
        '''Save the config db to a directory.
        '''
        self.diskMount('/dev/ad0s1a', target)
        self.config.save(target)
        self.diskUmount(target)
        return True

    def diskMount(self,partition,mountpoint,option='w'):
        '''Mount a partition
        '''
        if option not in ('r', 'w'):
            raise ValueError, 'Invalid option passed to mount: %s' % response.status
        if os.path.exists(mountpoint):
            if not subprocess.call(['/sbin/mount', '-%s' % option, partition, mountpoint]):
                return False
        else:
            return False
        return True

    def diskRemount(self,mountpoint,option=''):
        '''Remount a partition
        '''
        if option == '':
            option = 'w'
        if option not in ('r', 'w'):
            raise ValueError, 'Invalid option passed to mount: %s' % response.status
        if os.path.exists(mountpoint):
            subprocess.call(['/sbin/mount', '-u', '-%s' % option, mountpoint])

    def diskUmount(self,mountpoint):
        '''Unmount a partition
        '''
        if os.path.exists(mountpoint):
            if not subprocess.call(['/sbin/umount', mountpoint]):
                return False
        return True

    def netIfDown(self, ifaceName):
        '''Bring down a network interface
        '''
        if subprocess.call(['/sbin/ifconfig', ifaceName, 'down']): return True
        else: return False

    def netIfUp(self, ifaceName):
        '''Bring up a network interface
        '''
        if self.config.getVar('net.%s.enable' % ifaceName):
            ifaceInfo = self.config.getVars('net.%s' % ifaceName)
            if ifaceInfo['net.%s.proto'%ifaceName] == 'static':
                # check to make sure we have the interface to be configured
                rc = subprocess.call(['/sbin/ifconfig', ifaceName, ifaceInfo['net.%s.addr4'%ifaceName], 'netmask', ifaceInfo['net.%s.netmask4'%ifaceName]], shell=True)
                if rc == 0:
                    rc = subprocess.call(['/sbin/route', 'add', '-net', '0.0.0.0', '-netmask', '0.0.0.0', self.config.getVar('net.gateway4')], shell=True)
                else:
                    return False
            elif ifaceInfo['net.%s.proto'%ifaceName] == 'dhcp':
                rc = subprocess.call(['/sbin/dhclient', ifaceName])
                if rc > 0:
                    return False
            elif ifaceInfo['net.%s.proto'%ifaceName] == 'pppoe':
                pass
            else:
                # This is the last ditch effort to configure the interface
                pass
        else:
            print '%s is not configured. Leaving down.' % ifaceName
            self.config.setVar('net.%s.enable' % ifaceName, False)
            return False
        return True

    def netGetIfInfo(self, device):
        '''Get IPv4 information regarding a network device in a dictionary
        '''
        # get address and netmask of interface
        addr = netifaces.ifaddresses(device)[2][0]['addr']
        broadcast = netifaces.ifaddresses(device)[2][0]['broadcast']
        netmaskList = netifaces.ifaddresses(device)[2][0]['netmask'][6:].split(':')
        # translate elements to decimal
        i = 0
        while i < len(netmaskList):
            netmaskList[i] = int(netmaskList[i], 16)
            i += 1
        # add any necessary zeroes
        while len(netmaskList) < 4:
            netmaskList.append('0')
        # turn into a string
        netmask = ''
        for octet in netmaskList:
            netmask += '.'+str(octet)
        netmask = netmask[1:]
        # get the subnet's address
        network = networking.inet_itoa(networking.inet4atoi(addr) & networking.inet4atoi(netmask))
        return {'addr': addr, 'netmask': netmask, 'broadcast': broadcast, 'network': network}

    def netSetHostname(self):
        '''Set the hostname
        '''
        hostname = self.config.getVar('sys.hostname')
        f = open('/etc/hostname', 'w')
        f.write(hostname)
        f.close()
        subprocess.call(['hostname', hostname])
        
    def netSetIface(self, iface, proto, address='', netmask=''):
        '''Configure a network interface
        '''
        if addr4 == 'dhcp':
            self.config.setVar('net.%s.proto' % iface, 'dhcp')
        else:
            self.config.setVar('net.%s.proto' % iface, 'static')
            self.config.setVar('net.%s.addr4' % iface, addr4)
            self.config.setVar('net.%s.netmask4' % iface, netmask4)

    def randStr(self, len):
        '''Generate a random string
        '''
        if type(len) == int and len > 0:
            chars = ''.join(['abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ','1234567890','/.'])
            return ''.join([random.choice(chars) for i in range(len)])
        else:
            return ''

    def runCommand(command):
        '''Run a command.  Returns a string.
        '''
        cmdpath = '/usr/local/cmds'
        # get a list of valid external adjectives (commands)
        commands = os.listdir(cmdpath)
     
        if not command.getAdj():
            print 'Incomplete command. Try help.'
            return False

        # handle the external commands
        if command.getAdj() not in commands:
            print 'ERR: Can not perform %s on %s. %s does not exist.' % (command.getVerb(), command.getAdj(), command.getAdj())
        else:
            # split up commands
            verb = command.getVerb()
            adj = command.getAdj()
            nouns = command.getNouns()
            # "import" the right set of verbs for a given adjective
            execfile('%s/%s' % (cmdpath, adj))

    def shutdown(self, type='halt'):
        '''Shutdown the appliance.  Pass an argument of either "halt" or "reboot".
        '''
        type = type.lower()
        if type == 'halt':
            syslog.syslog(syslog.LOG_NOTICE, 'System shutdown started.')
        elif type == 'reboot':
            syslog.syslog(syslog.LOG_NOTICE, 'System reboot started.')
        # Shutdown all services
        svcList = self.svcGetDepList('*')
        svcList.reverse()
        for svc in svcList:
            self.svcAction(svc, 'stop')
        if type == 'halt':
            subprocess.call(['/sbin/halt', '-p'])
        elif type == 'reboot':
            subprocess.call(['/sbin/reboot'])
        return True

    def svcGetDepList(self,service='*'):
        '''Create the service dependency list for booting.
           Return a list.
        '''
        if type(service) != str:
            print 'ERR: argument is not of type str'
            return []

        depList = []
        # for each enabled service...
        for key, val in self.config.getVars('svc.'+service+'.enable').iteritems():
            if val == True:
                walkStack = []
                pkgName = key.split('.')[1]
                walkStack.append(pkgName)
                # walk through the dependency tree
                while len(walkStack) > 0:
                    pkg = walkStack.pop()
                    if not pkg in depList:
                        deps = self.config.getVar('svc.'+pkg+'.deps').split(' ')
                        # If there are no dependencies, deps[0] will be ''
                        if deps[0] != '':
                            walkStack.extend(deps)
                        else:
                            if not pkg in depList:
                                depList.append(pkg)
                if not pkgName in depList:
                    depList.append(pkgName)
        return depList

    def svcAction(self, service, action):
        '''Perform an action on a service.
        '''
        retVal = True

        if os.path.exists('/etc/rc.d/%s.py' % service) or os.path.exists('/usr/local/etc/rc.d/%s.py' % service):
            if action.lower() == 'start':
                syslog.syslog(syslog.LOG_INFO, 'Starting %s' % service)
                if self.config.getVar('svc.%s.enable' % service):
                    foo = __import__('%s' % service, globals(), locals())
                    svc = foo.Service(self, self.config)
                    if not svc.start():
                        syslog.syslog(syslog.LOG_ERR, 'Service %s failed to start.' % service)
                        retVal = False
                else:
                    syslog.syslog(syslog.LOG_WARNING, 'Cannot start %s. %s not enabled.' % (service, service))
                    retVal = False
            elif action.lower() == 'stop':
                syslog.syslog(syslog.LOG_INFO, 'Stopping %s' % service)
                foo = __import__('%s' % service, globals(), locals())
                svc = foo.Service(self, self.config)
                if not svc.stop():
                    syslog.syslog(syslog.LOG_ERR, 'Service %s failed to stop.' % service)
                    retVal = False
            elif action.lower() == 'restart':
                syslog.syslog(syslog.LOG_INFO, 'Restarting %s' % service)
            elif action.lower() == 'reload':
                syslog.syslog(syslog.LOG_INFO, 'Reloading %s' % service)
            elif action.lower() == 'stat':
                pass
            else:
                syslog.syslog(syslog.LOG_ERR, 'Invalid service action: %s' % action)
                retVal = False
        else:
            syslog.syslog(syslog.LOG_WARNING, 'Service script for %s not found.' % service)
            retVal = False

        return retVal

    def timeGenLocal(self):
        if os.path.exists('/etc/localtime'):
            os.unlink('/etc/localtime')
        os.symlink('/usr/share/zoneinfo/%s' % (self.config.getVar('sys.tz')), '/etc/localtime')
        subprocess.call(['adjkerntz', '-i'])

    def timeSetZone(self, tz):
        '''Set the timezone.
        '''
        self.config.setVar('sys.tz', tz)
        self.timeGenLocal()

    def userAdd(self,username,gecos,password,sflags='U',shell='/bin/false'):
        sflags = '[%s%s]' % (sflags,'           '[len(sflags):])
        # Get lowest available uid
        uidlist = self.config.getVars('user..*.uid').values()
        # Initial value for uid
        uid = 1001
        while uid < 65536:
            if uid in uidlist:
                uid += 1
            else:
                break
        else:
            syslog.syslog(syslog.LOG_ERR, "addUser(): ran out of uid's")
            return 1

        # Add user to config
        self.config.setVar('user.%s.enable' % username, 'True')
        self.config.setVar('user.%s.uid' % username, str(uid))
        self.config.setVar('user.%s.gid' % username, self.config.getVar('group.users.id'))
        self.setUpasswd(username,password)
        self.setSpasswd(username,password)
        self.config.setVar('user.%s.sflags' % username, sflags)
        self.config.setVar('user.%s.gecos' % username, gecos)
        self.config.setVar('user.%s.home' % username, '/home/'+username)
        self.config.setVar('user.%s.shell' % username, shell)
        self.config.setVar('user.%s.lct' % username, 'LCT-'+hex(int(time.time()))[2:].upper())

        # Re-generate passwd, group, and samba files
        self.passwdGenGroupFiles()
        self.passwdGenFiles()
        self.passwdGenSambaFiles()

    def userDel(self,username):
        pass

    def userMod(self,username,attribute,value):
        pass

    def versGetCurrent(self):
        '''Return the firmware's current version
        '''
        current = config.getVar('sys.version')
        current = current.split('.', 3)
        return current

    def versGetLatest(self):
        '''Check for the latest version of firmware
        '''
        import httplib
        try:
            url = httplib.HTTPConnection('satellite.zahna.com')
            url.request('GET', '/latest.txt')
            response = url.getresponse()
            if response.status != httplib.OK:
                raise Exception('Received status %s from http server' % (response.status))
        except:
            syslog.syslog(syslog.LOG_ERR, "Can't fetch latest version info")
            exit(1)

        latest = response.read()
        url.close()

        if latest[-1] == '\n':
            latest = latest[:-1]
        latest = latest.split('.', 3)
        return latest
        
    def versUpgrade(self):
        # Renice this script
        os.nice(19)

        # Get the current "/" partition and the one to upgrade to
        f.open('/etc/fstab')
        if re.match(".*ad0s1b\s+/\s",f.read()):
            currpart = 'ad0s1b'
            upgpart = 'ad0s1d'
        else:
            currpart = 'ad0s1d'
            upgpart = 'ad0s1b'

        # Create and mount the work partition
        subprocess.call(['mdconfig -a -t malloc -o reserve -s 64m -u 10 && newfs -b 4096 -f 512 -i 4096 -o space -m 0 md10 && mount /dev/md10 /upg/work'], shell=True)

        # Mount the upgrade partition
        subprocess.call(['mount', '/dev/'+upgpart, '/upg/root'])

        current = self.get_current_version()
        latest = self.get_latest_version()

        # Compare and download the system image upgrade
        if current[0] < latest[0] or \
            (current[0] == latest[0] and current[1] < latest[1]) or \
            (current[0] == latest[0] and current[1] == latest[1] and current[2] < latest[2]):
            upgrade = True
        else:
            syslog.syslog(syslog.LOG_NOTICE, "System is already the latest version.")
            exit(0)

        # Download upgrade into the work partition
        url.request('GET', '/system-%s.tar.gz' % (latest.join('.')))
        f = open('/upg/work', 'w')
        f.write(url.read())
        f.close()

        # Clear out the other partition
        subprocess.call(['rm -rf /upg/root/*'], shell=True)
        #for root, dirs, files in os.walk('/upg/root', topdown=False):
        #    for name in files:
        #        os.remove(os.path.join(root, name))
        #    for name in dirs:
        #        os.rmdir(os.path.join(root, name))

        # Unpack upgrade into the other partition

        # Update the "/" partition in the new system /etc/fstab

        # Update the "/" partition in boot.config

        # Umount the upgrade partition
        subprocess.call(['umount', '/upg/root'])

        # Umount and destroy the md disk
        subprocess.call(['umount', '/upg/work'])
        subprocess.call(['mdconfig', '-d', '-u', '10']) 



