import os
import socket
import select
from time import time
import syslog

'''This is the MCP (Management and Control Protocol) module.
It's provides an agent class which can be used to construct either a
server or a client.
'''

class MCPMessage(dict):
    '''The MCP Message object.
    '''
    def __init__(self, type='ENQ'):
        '''Create an MCP message.  Default type is ENQ.
        '''
        self['version'] = 2
        self['type'] = type
        self['length'] = 0
        self['userpass'] = ''
        self['payload'] = ''

    def reset(self):
        self.clear()
        self.__init__()
        return True

    def input(self, string):
        '''Take a string and split it up correctly into this object.
        '''
        try:
            lines = string.split('\n', 4)
            for line in lines:
                self['version'] = int(lines[0])
                self['type'] = lines[1]
                self['length'] = int(lines[2])
                if len(lines) > 3: self['userpass'] = lines[3]
                if len(lines) > 4: self['payload'] = lines[4]
        except:
            return False
        return True 

    def asString(self):
        '''Returns the MCP message as a string for easy sockets transmission.
        '''
        output = '%i\n%s\n%i' % (self['version'], self['type'], len(self['payload']))
        output += '\n'
        if self['userpass']: output += '%s' % self['userpass']
        output += '\n'
        if self['payload']: output += '%s' % self['payload']
        return output



class MCPAgent(object):
    '''The MCP Agent object.
    '''
    def __init__(self):
        self.listeners = []
        self.recvLength = 4096
        self.acceptTimeo = 1
        self.recvTimeo = 600
        self.sendTimeo = 60

    def listen(self, family, type, addr):
        '''Add a socket to the socket list.  This is for listening sockets.
        '''
        if family == socket.AF_UNIX:
            if os.path.exists(addr):
                raise socket.error, 'socket already exists: "%s"' % (addr)

        sock = socket.socket(family, type)
        sock.bind(addr)
        sock.listen(1)
        self.listeners.append(sock)

    def connect(self, family, type, addr):
        '''Connect to another MCP Agent somewhere.
        '''
        sock = socket.socket(family, type)
        sock.connect(addr)
        return(sock)

    def accept(self, acceptTimeo=1):
        '''Accept connections on all listening ports.  Return a list of
           tuples of accepted connections and IP addresses (for stream socks).
        '''
        if self.acceptTimeo != acceptTimeo:
            self.acceptTimeo = acceptTimeo

        try:
            if acceptTimeo < 0:
                rds, wrs, exs = select.select(self.listeners, [], [])
            else:
                rds, wrs, exs = select.select(self.listeners, [], [], acceptTimeo)
        except select.error:
            pass

        conns = []
        for rd in rds:
            conns.append(rd.accept())
        return(conns)

    def recv(self, sock, addr=None):
        '''Receive data on a socket.  Returns an MCPMessage on success.
        Raises a socket exception if an error occurs.
        '''
        message = MCPMessage()
        first = True
        try:
            while True:
                rd, wr, ex = select.select([sock], [], [], self.recvTimeo)
                # Get the rest of the payload here
                if rd:
                    data = sock.recv(self.recvLength)
                    if first:
                        # process the header here
                        message.input(data)
                        first = False
                    else:
                        message['payload'] += data
                    #syslog.syslog(syslog.LOG_NOTICE, 'message: %s' % message.asString())
                    #syslog.syslog(syslog.LOG_NOTICE, 'len(message[\'payload\']) is %i' % len(message['payload']))
                    #syslog.syslog(syslog.LOG_NOTICE, 'message[\'length\'] is %i' % message['length'])
                    if len(message['payload']) >= message['length']: break
                else:
                    self.close(sock)
                    raise socket.error, 'Connection timed out'
                    break
            return message
        except socket.error:
            self.close(sock)
            raise socket.error, 'Connection went away'

    def send(self, message, sock):
        '''Send data on a socket.  Returns True on success.  Raises
           a socket exception if an error occurs.
        '''
        if type(message) != MCPMessage:
            raise TypeError, 'Message is of type %s, which is not of type MCP.MCPMessage' % type(message)
        try:
            rd, wr, ex = select.select([], [sock], [], self.sendTimeo)
            if wr:
                    message['length'] = len(message['payload'])
                    sock.sendall(message.asString())
            else:
                self.close(sock)
                raise socket.error, 'connection timed out'
            return(True)
        except:
            self.close(sock)
            raise socket.error, 'connection went away'
        
    def close(self, sock, addr=None):
        '''Closes a socket.  Raises an exception if there's a problem.
        '''
        try:
            sock.shutdown(socket.SHUT_RDWR)
        except:
            pass
        sock.close()

    def run(self, handler):
        '''Accept a connection and call handler to handle it.
           The handler must accept a socket as an argument.
        '''
        while True:
            conns = self.accept()
            for conn in conns:
                handler(conn)

